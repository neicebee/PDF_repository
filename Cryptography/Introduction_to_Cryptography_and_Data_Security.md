# 💻 2025-1 Cryptography

## 👀 [01] Introduction to Cryptography and Data Security

### 암호학에 관한 분류
- Cryptology 암호학
  - Cryptography 암호기술: 메시지의 의미를 숨길 목적으로 비밀을 생성하는 과학
    - Symmetric Ciphers 대칭 암호
      - Block Ciphers 블록 암호
      - Stream Ciphers 스트림 암호
    - Asymmetric Ciphers 비대칭 암호
    - Protocols 프로토콜
  - Cryptanalysis 암호분석: 암호시스템을 무력화시키는 과학 또는 기술

<br>

### 기본 사항
- 고대 암호(Ancient Crypto)
  - 문자 기반의 암호기법
- 대칭 암호(Symmetric Ciphers)
  - 고대 암호로부터 1976년까지의 모든 암호는 비밀키를 이용한 대칭 암호
- 비대칭 암호(Asymmetric Ciphers)
  - 1976년 Whitfield Diffie, Martin Hellman, Ralph Merkle이 공개키(혹은 비대칭키) 암호기술 제안
- 하이브리드 기법(Hybrid Schemes)
  - 대칭 암호와 비대칭 암호 함께 사용
  - 대칭 암호: 암호화 및 메시지 인증 등
  - 비대칭 암호: 키 교환 및 전자서명 등

<br>

### 대칭 암호
- **대칭키(비밀키) 암호기법**
  - Problem
    - Alice와 Bob이 통신하는 채널(WLAN or Internet)은 안전하지 않음
    - 악의적인 제 3자 Oscar는 채널에 접속 가능하나 통신 내용을 이해할 수는 없어야 함
  - Solution
    - 대칭 암호를 이용해 암호화
    - Oscar가 획득한 암호문은 랜덤 비트처럼 보임
    - **안전한 통신을 위해서는 키의 안전한 전송 및 저장이 중요**
  - x: Plaintext, y: Ciphertext, k: key
    - 암호화 식: $y=e_k(x)$
    - 복호화 식: $x=d_k(y)$
    - 동일한 키 $k$가 암호화와 복호화에 사용되었다면 두 변환은 서로 역의 관계에 있음
      - $d_k(y)=d_k(e_k(x))=x$

<br>

### 암호분석이 필요한 이유
- 실제 사용하는 암호의 안전성에 관한 수학적 증명은 존재하지 않음
- 암호가 안전하다는 것을 보장하는 유일한 방법
  - 암호 해독 시도
- **Kerchkoff's Principle**: 현대 암호기술에서 중요한 원칙
  - **_암호시스템은 공격자가 비밀키를 제외한 시스템의 모든 상세한 사항을 알고 있어도 안전해야 한다. 특히 공격자가 암호화/복호화 알고리즘을 알고 있을 때에도 시스템은 안전해야 한다._**
  - 암호학자들이 여러 해 동안 암호분석을 한 잘 알려진 암호만을 사용해야 함
    - 개발자가 시스템을 설계할 때 좀 더 안전해 보이도록 암호의 상세한 사항을 숨김
    - 역사적으로 이러한 시스템은 거의 항상 안전하지 않았으며 설계 방법이 역공학 등의 다른 수단을 통해 노출되었을 때 쉽게 무력화됨

<br>

### 암호분석: 암호시스템 공격(Attacking Cryptosystems)
- 고전적 공격(Classical Attacks)
  - 수학적 분석 및 무작위 공격
- 구현 공격(Implementation Attacks)
  - 역공학 또는 전력 측정 등을 통해 키를 추출하려는 공격
- 사회 공학(Social Engineering)을 이용한 공격
  - 사용자를 속여 패스워드를 제출하도록 함(피싱 등)

<br>

### 대칭 암호에 대한 무작위 공격(Brute-Force Attack or Exhaustive Key Search)
- 최소 1개의 평문-암호문 쌍이 필요
- 다음을 만족할 때까지 가능한 모든 키로 확인
  - $d_k(y_0)=^?x_0$
- 공격자는 한번의 공격만으로 성공할 수 있음
  - 다른 공격이 가능하다면 긴 길이의 키 공간이라도 별 소용이 없을 수 있음

<br>

### 대치 암호(Substitution Cipher)
- 대표적인 고전 암호로 무작위 공격과 분석 공격을 이해하는 데 도움이 됨
- **목적: 글자를 암호화하는 것**
- **아이디어: 평문의 각 문자를 다른 문자로 치환하는 것**
- `iq ifcc vqqr fb rdq vfllcq na rdq cfjwhwz hr bnnb hcc hwwhbsqvqbre hwq vhlq`
  - 무작위 또는 소모적 키 탐색
    - 식별 가능한 평문이 나타날 때까지 가능한 모든 대치 표를 시도함
    - 문자 A에 대한 대체 문자를 선택하려고 하면 알파벳의 26개 문자 중 하나를 임의 선택함
      - 대치 표의 키 공간 = $26!=2^{88}$
    - 무작위 공격이 실현 불가하다고 대치 암호가 안전하다고 결론내릴 수는 없음
      - 모든 가능한 공격에 대해 대책 수립 필요
  - 문자 빈도 분석(Letter Frequency Attack)
    - 암호의 주 취약점: _각 평문의 문자가 항상 동일한 암호문의 문자와 대응된다는 것_
    - **빈도 분포는 일반적으로 사용된 언어의 빈도 분포와 비슷함**
      - 즉, 문자 q가 영어에서 가장 빈번하게 나타나는 문자 중 하나가 대치되었음
    - **문자를 묶어서 앞의 규칙을 일반화할 수 있음**
      - 영어 및 다른 유럽 언어에서 대부분의 문자 Q 다음에 문자 U가 오며, 문자 T 다음 H가 나타남
    - **단어 구분이 있다고 가정하면, THE, AND 등과 같이 빈번하게 나타나는 짧은 단어를 찾아낼 수 있음**
  - `we will meet in the middle of the library at noon all arrangements are made`
- **Point**
  - 좋은 암호는 암호화된 평문의 통계적 특성을 숨겨야 함
  - 암호문의 문자가 임의의 형태로 보이도록 해야 함
  - 큰 키 공간만으로 강한 암호화 함수를 만들기엔 충분치 않음

<br>

### 모듈러 연산 개론(Short Introduction to Modular Arithmetic)
- 비대칭 암호기술(RSA, 타원 곡선 등)에 매우 중요
- 일부 고전 암호(시저 암호, 아핀 암호 등)가 모듈러 연산으로 표현 가능
- _일반적으로 대부분의 암호시스템은 다음의 특성을 갖는 수의 집합에 기반을 둠_
  - **이산적(Discrete): 정수의 집합이 특히 유용**
    - Number Theory(정수론)
  - **유한적(Finite): 유한개의 수로만 계산을 수행**
  - 이산적인 수를 갖는 유한 집합 => 시계
    - 매 시간마다 수가 증가해도 `1, 2, 3, ... 11, 12, 1, 2, 3, ...` 이라는 수만 반복
- 유한의 정수 집합에서 계산할 수 있는 산술체계
  - **제한된 정수를 유지하도록 하는** 연산은 매우 중요
    - 즉, 덧셈 및 곱셈의 결과가 해당 집합 내에 존재보다 클 수 없음
- 모듈러 연산의 정의
  - $a, r, m$은 정수이고 $m>0$에 대하여
  - $a\equiv{r}$ $mod$ $m$
  - $(a-r)$이 $m$으로 나눠지면 $m$은 Modulus, $r$은 Remainder라고 함
  - $a=12,$ $m=9$ => $12\equiv{3}$ $mod$ $9$
  - $a=-7,$ $m=9$ => $7\equiv{2}$ $mod$ $9$

<br>

### 모듈러 연산의 특성(Properties of Modular Arithmetic)
- Remainder는 유일하지 않음(무한대로 많은 유효한 Remainder 존재)
  - $12\equiv{3}$ $mod$ $9$ => $9|(12-3)$
  - $12\equiv{21}$ $mod$ $9$ => $9|(12-21)$
  - $12\equiv{-6}$ $mod$ $9$ => $9|(12-(-6))$
  - $mod9$에 대해서는 다음과 같이 서로 다른 9개의 동치류(EquivalenceClass)가 존재
- 나머지 선택에 관하여
  - 관례상 가장 작은 양의 정수 $r$을 나머지로 선택
    - $a=q*m+r$, $where$ $0\leq{r}\leq{m-1}$
    - 암호 함수 계산을 위해서는 알고리즘적으로 자유롭게 다른 유효한 나머지를 선택할 수 있어야 함
- 모듈러 나눗셈
  - 나눗셈을 실행하기 보다는 **역원을 곱하는 것** 선호
    - $\frac{b}{a}\equiv{b}\times{a}^{-1}$ $mod$ $m$
  - 정수 $a$의 역원 $a^{-1}$: $a\times{a}^{-1}\equiv{1}$ $mod$ $m$
    - $\frac{5}{7}$ $mod$ $9$
      - $7$ $mod$ $9$의 역원은 4
      - $7\times{4}=28\equiv{1}mod9$
      - 따라서, $\frac{5}{7}\equiv5\times{4}=20\equiv{2}$ $mod$ $9$
- 역원의 계산
  - 정수 $a$ $mod$ $m$의 역원은 다음을 만족하는 경우에만 존재함
    - $acd(a, m)=1$
      - gcd(Greatest Common Divisor): 최대 공약수
  - 현재로써 역원 계산법은 소모적 탐색을 해보는 것
    - 효율적 계산을 위해서는 유클리드 알고리즘 또는 유클리드 호제법 학습 필요
- 모듈러 축소(Modular Reduction)는 계산 중 언제든지 실행 가능
  - $3^8$ $mod$ $7$
    - 지수승 계산은 공개키 암호기술에서 매우 중요함
    - **Approach 1**: 지수승 계산 후 모듈러 축소 실행
      - $3^8=6561=937*7+2\equiv{2}$ $mod$ $7$
    - **Approach 2**: 계산 중간에 모듈러 축소 실행하며 지수승 계산
      - $3^8=3^4*3^4=81*81$
      - $81$ $mod$ $7=4$의 결과 이용
        - $3^8=81*81\equiv{4}*4=16$ $mod$ $7$
        - $16\equiv{2}$ $mod$ $7$
    - Approach 2가 보다 효율적
  - **대부분의 알고리즘에서 가능하면 중간 결과에 모듈러 축소를 실행하면서 계산을 진행하는 방법이 보다 효율적임**

<br>

### 모듈러 연산의 대수학적 관점(Algebraic View): 환(Ring) $Z_m-1$
- 정수환(Integer Ring) $Z_m$
  - 정수환 $Z_m$은 다음과 같음
  - 집합 $Z_m={0,1,2,...,m-1}$
  - 모든 $a,$ $b\in{Z_m}$에 대한 두 연산 "+"와 "$\times$"는 다음과 같음
    - $a+b\equiv{c}$ $mod$ $m,$ $(c\in{Z_m})$
    - $a\times{b}\equiv{d}$ $mod$ $m,$ $(d\in{Z_m})$
- $m=9$인 정수환 $Z_9={0,1,...,8}$에 대해 다음의 간단한 산술 연산 가능
  - $6+8=14\equiv{5}$ $mod$ $9$
  - $6\times{8}=48\equiv{3}$ $mod$ $9$
  - 즉, $5,$ $3\in{Z_9}$
- 모듈러 $m$ 상에서의 산술 연산을 통해 다음의 특성을 갖는 정수환 $Z_m$을 얻음
  - 닫혀 있음(Closure): 두 수를 더하거나 곱한 결과가 항상 환의 원소
  - 덧셈과 곱셉은 결합법칙(Associative) 성립
    - 즉, 모든 $a,$ $b,$ $c\in{Z_m}$에 대해
      - $a+(b+c)=(a+b)+c$
      - $a\times(b\times{c})=(a\times{b})\times{c}$
    - 그리고, 덧셈은 교환법칙(Commutative) 성립
      - $a+b=b+a$
  - 배분법칙(Distributive) 성립
    - 즉, 모든 $a,$ $b,$ $c\in{Z_m}$에 대해
      - $a\times(b+c)=(a\times{b})+(a\times{c})$
  - 덧셈에 대한 항등원 0이 존재함
    - 즉, 모든 $a\in{Z_m}$에 대해
      - $a+0\equiv{a}$ $mod$ $m$
  - 모든 $a\in{Z_m}$에 대해 다음을 만족하는 덧셈에 대한 역원 $-a$가 항상 존재함
    - $a+(-a)\equiv{0}$ $mod$ $m$
  - 곱셈에 대한 항등원 1이 존재함
    - 즉, 모든 $a\in{Z_m}$에 대해
      - $a\times{1}\equiv{a}$ $mod$ $m$
  - 곱셈에 대한 역원 $a^{-1}$은 $a\times{a}^{-1}\equiv{1}$ $mod$ $m$
    - $Z_m$ 내의 모든 원소가 아닌 특정한 원소에 대해서만 존재함
- 정수환은 덧셈, 뺄셈, 곱셈은 항상 실행 가능하나, 특정 원소에 대해서만 나눗셈이 가능
  - 나눗셈을 실행하기 위해서는 해당 원소의 곱셈에 대한 역원이 존재해야 함
  - 임의의 $a\in{Z_m}$에 대해 다음을 만족하는 경우에만 곱셈에 대한 역원 존재
    - $gcd(a,$ $m)=1$
  - $gcd(a,m)=1$을 만족할 때, $a$와 $m$을 서로소(Relatively Prime or Coprime) 관계에 있다고 함
  - 정수환 $Z_9={0,1,2,...,8}$에 대해서 원소 0, 3, 6은 9와 서로소 관계에 있지 않기 때문에 역원이 존재하지 않음
  - 1, 2, 4, 5, 7, 8에 대한 역원은 다음과 같음
    - $1^{-1}\equiv{1}$ $mod$ $9$
    - $2^{-1}\equiv{5}$ $mod$ $9$
    - $4^{-1}\equiv{7}$ $mod$ $9$
    - $5^{-1}\equiv{2}$ $mod$ $9$
    - $7^{-1}\equiv{4}$ $mod$ $9$
    - $8^{-1}\equiv{8}$ $mod$ $9$

<br>

### 이동 또는 시저 암호(Shift(or Caeser) Cipher)
- 고대 암호로 Julius Caesar가 사용했다고 알려짐
- 평문의 각 문자를 다른 문자로 치환
- 단순한 변환 규칙
  - 알파벳 순에서 k만큼 뒤의 문자로 치환 후 문자에서 숫자로 대응
  - 이동은 순환됨
  - $k=17$
    - 평문: attack => 0, 19, 19, 0, 2, 10
    - 암호문: rkkrtb => 17, 10, 10, 17, 19, 1
  - 수학적으로 모듈러 26 상의 축소로 표현 가능
    - $19+7=26\equiv{0}$ $mod$ $26$
- 수학적 표현
  - $x,y,k\in{Z_26}={0,1,2,...,25}$에 대하여
  - Encryption: $y=e_k(x)\equiv{x}+k$ $mod$ $26$
  - Decryption: $x=d_k(y)\equiv{y}-k$ $mod$ $26$
- 안전한가?
  - No. 다양한 공격이 가능함
    - 소모적 키 탐색(Exhaustive Key Search): 키 공간은 $26!$
    - 대치 암호와 비슷하게 문자 빈도 분석을 이용한 공격 가능

<br>

### 아핀 암호(Affine Cipher)
- 이동 암호의 확장: 평문에 키를 더할 뿐만 아니라 키를 곱함
- 두 부분으로 구성된 키 이용: $k=(a,b)$
  - $x,y,a,b\in{Z_26}={0,1,2,...,25}$에 대하여
  - Encryption: $y=e_k(x)\equiv{a}x+b$ $mod$ $26$
  - Decryption: $x=d_k(y)\equiv{a^{-1}}(y-b)$ $mod$ $26$
- 복호화에 $a$의 역원이 필요하기에 다음을 만족하는 $a$만 사용 가능: $gcd(a,26)=1$
  - 이 조건을 만족하는 정수는 12개: $a\in{1,3,5,7,9,11,15,17,19,21,23,25}$
  - $a=3$에 대해 $3\times{9}=27\equiv{1}$ $mod$ $26$이므로 $a^{-1}=9$이고 이는 $gcd(a^{-1},26)=1$을 만족함
- 키 공간은 $12\times26=312$
- 소모적 키 탐색 및 문자 빈도 분석 등을 이용한 공격과 같은 다양한 공격 가능
